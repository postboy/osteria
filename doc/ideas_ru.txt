	УЛУЧШЕНИЯ И ИСПРАВЛЕНИЯ
в первую очередь отсортировать все эти пожелания!
как можно меньше глобальных переменных
если была вставка (insert/paste) в буфер, то считывать его до конца, иначе только строку. Возможно, через глобальную переменную
больше шрифт в окне беседы
хеш(меньший ключ, больший ключ в результате безопасного сравнения)
внедрить структуру «все 6 ключей» для упрощения интерфейсов функций? Переменные M[aster] и S[ession]
Обязательно ли все memcpy в конце вставлять?
хеши от сеансовых ключей тоже показывать
всё ещё нет защиты от вбрасывания в канал шума
recv(зашифрованный и подписанный размер информационной части, известный размер, без MSG_WAITALL) + recv(сообщение, нужный размер, MSG_WAITALL)
вывод данных о возрасте ключей
возможность обновлять постоянные ключи при надёжном соединении
хеши сеансовых ключей тоже показывать?
при сохранении ключей текущего сеанса на другой стороне может выводиться предложение сделать то же самое
режимы проверки «показ хэшей»
проверка на размер входящего сообщения, мин. и макс.
Неправильный размер = ресив (65к)
самый первый байт — тип сообщения
описать сообщение как тип «запись»?
Проверить вручную, нет ли переполнений буфера
проверка и защита от бинарных уязвимостей с помощью спецпрограмм (например, из старого Хакера)
обмен ключами по сети: постоянные ключи можно хранить лишь 1-ю минуту разговора, дальше стираются, либо вообще заранее нужно указывать
Нонсы из хешей защищают также и от утаивания определённых сообщений (но не первых нескольких из-за псевдослучаного генерирования первого из них). Почему бы не использовать в качестве нонса для первого сообщения хеш от постоянных публичных ключей?
выбор языка
ручная оптимизация glade-файлов
при изменении содержания проверять количество строк, когда 2 строки — отправить?
Чтобы нонс 1-го сообщения был всегда разным, можно сделать его хешем от таймстемпа, если он не зависит от часового пояса. Передаём свой т. вместе с 1-м сообщением. Если принятый т. отличается от вычисленного нами более, чем на какую-то величину (минуту, например), то разрыв соединения.
Можно сначала пингануть, потом время пинга умножить на 5 и получить возможную разницу между т. Кто первый пингует, можно определить по хешам.
С 1-м нонсом рационально поступить так: половину генерим сами, половину берём от собеседника, получившийся набор хешируем.
Нонс вообще незатратно можно генерить из хеша от сеансовых публичных ключей
согласование режимов работы собеседников (в том числе режим работы с ключами, версия)
«пользователь набирает сообщение...»
иконка для приложения
раскидать main.c на пару файлов в зависимости от обрабатываемого окна
на ноуте в окнах settings и talk:
«gtk_application_get_app_menu assertion 'GTK_IS_APPLICATION (application)' failed
gtk_application_get_menubar assertion 'GTK_IS_APPLICATION (application)' failed»
возможно, связано с атрибутами visible — сохранил ответ на stackoverflow в избранные
может фейлится из-за отсутствия регистрации в системе
пустую строку не передавать (минимум не передавать просто перевод строки, в идеале ещё и пробелы)
Если курсор во время нажатия Enter не в конце, то передаётся не всё сообщение. Это проблему (почти) решит считывание с 1-го символа 1-й строки до последнего последней строки (это поможет и при вставке буфера с более чем 1 строкой). Но тогда нужно будет разобраться с унификацией вывода, с этим были проблемы, сообщения выглядели по-разному.
Выбор собедесника из меню
сохранение параметров для беседы
центральный сервер, перебрасывающий сообщения собеседнику
звук при получении сообщения
хеши показывать в месседжбоксе (сделать такой пункт меню)
не будет ли гонок из-за глобальных переменных?
Обработчик нажатия (не отпускания!) Enter: sleep(100) + считать всё
вообще отличное решение: полная защита от утаивания, даже если с одной стороны злоумышленник
- оба генерят по случайному нонсу
-хеш(свой нонс, чужой) — свой 1-й нонс
-хеш(чужой нонс, свой) — чужой 1-й нонс
вместо сверки хешей можно намутить взаимную аутентификацию с помощью модели рукопожатий, секрет — парольная фраза. Сильно пригодится key stretching
при обмене сессионными ключами такие огромные буферы и столько ненужных переменных
дописать в комментах код неблокирующего чтения и генерации случайных чисел и использования winsock.h в винде (что именно он заменяет?), других сетевых функций для соляриса
изучить, можно ли написать что-то типа IFDEF WINDOWS
какя именно библиотека конфликтует с пойзоном
очень не хватает согласования режимов работы клиента и сервера
//unportable part begin
123	//windows only
//unportable part end
генерация 1-го нонса:
1. две стороны генерят случанные данные д1 и д2
2. нонс1 = хеш(д1, д2), нонс2 = хеш(д2, д1)
вместо данных могут быть постоянные публичные ключи, тогда показывать на экране надо хеш от хеша (чтобы не продиктовать по телефону нонс при обмене постоянными ключами не по сети, ибо ненужная утечка данных)
NaCl может подсказать, как организовать кросс-компиляцию
изучить распечатанные исходники TweetNaCl
OTR задача социалиста-миллионера для защиты от МиТМ. Как самому сделать? Протокол взаимной аутентификации на основе хеша(открытые ключи, секрет, вызов). Нежны медленные хеши для защиты от брутфорса секрета
согласование версий протокола, программы
возможность исп. Вместо постоянных ключей ключи симметричного шифрования, генерируемые на обоих сторонах путём ввода пароля и его хешировния в scrypt
режим анти-босса (скритие присутствия при нажатии на определённые клавиши)
идентификатор static перед встроенными в модуль функциями
возможно, переход на NaCl для скорости, с оставлением TweetNaCl для случая, когда платформа не поддерживается в NaCl
1-я стадия, обмен сеансовыми ключами: зашифровать их симметричным шифром, причём обе стороны получают ключ шифрования из парольной фразы => защита от MiTM
ключевое слово extern может помочь избавиться от взаимных ссылок в h-файлах, или по крайней мере увеличить читабельность кода
идентификаторы const для параметров функций
есть глобальная переменная = возможны гонки, всё детально перепроверить


	БУДУЩЕЕ
Включение и выключение шифрования и разных опций через комндную строку
сохранение лога общения в файл
автоматический чек внешнего и локального адресов на сервере через system(), скажем
записать в большой буфер случайные данные, а в его начало - зарезервированное сообщение с возможностями программы
унификация ввода с помощью stty
интернационализация с помощью gettext()
//цвет текста — в виме или нано наверняка есть
getnameinfo(), возможно, позволяет организовать общение в ЛС, зная hostname (не IP!) сервера
общение более двух людей
передача файлов с использованием симметричного шифрования для увеличения производительности (гибридная криптосистема)
возможность задавать различные степени защиты
попробовать зарегать порт в IANA
select(exeptfds)
флаги для send() и recieve()
AI_FLAGS = AI_PASSIVE
setsockopt()
баг: если сообщение приходит во время набора сообщения, то набросок остаётся на экране, после него сразу сообщение, а новая строка пуста
Редактирование последнего символа сообщения работает как должно?
клавиши вверх, вниз, влево, вправо управляют выводом, причём на принимающей машине, а не на отправляющей — запретить ^? F12 + сообщение тоже корёжит вывод на приёмной стороне

	ПАРАНОЙЯ
убрать название и версию, хэлп, флагом для gcc убрать отладочную информацию из бинарика
очищать stdin, stdout, чтобы там ничего не оставалось ни в каких буферах, в stderr просто ничего не писать
рандомизировать имена
отключить откачку страниц памяти в своп-файл/раздел
//вим нано лесс ман как очищают экран после работы?
запрет SO_REUSEADDR и другая повышенная забота о приватности (занулять всё в ОП, когда уже не нужно)
генерация белого шума в сети — мусорного трафика, псевдосообщений
придать сообщениям одинаковый размер и высылать их более-менее регулярно (для неотличения от шума), как совсем параноидальную опцию
Два компьютера соединяются с сервером, один из них открывает у себя программу-сервер, второй программу-клиент, и дальше два компьютера общаются напрямую, а не через сервер. Меньше нагрузка на сервер, большая безопасность (сервер может быть аутентифицирован сертификатом TLS).
обнуление всех личных данных и сообщений в ОП так скоро, как только можно
Аутентификация по знанию секрета: плейн-текст пароль считывается НЕ из параметров запуска (там можно только задать его наличие/отсутствие), а так, чтобы его не было видно на экране (не выводить даже звёздочки). 1000 хэшей, отправили — 1000 хэшей, вывели на экран, сравнили с ранее известным результатом. Как можно скорее удалять отовсюду.
Сервер шлёт хэш от пароля, потом соль к нему. Клиент, принимая соль, считает хэш от своего пароля с заданной сервером солью. Если совпал, то шлёт серверу нехэшированный пароль, сервер сравнивает пароль со своим (или те же действия повторяются со сменой ролей на противоположные).
Два клиента хотят связаться. Посылают серверу, защищённому TLS, свои логины и пароли, логины желаемых собеседников. Сервер кидает им IP и порт собеседника, если он онлайн. Сначала клиент с младшим хешем от ника пытается подключиться к серверу со старшим хешем, в случае неуспеха наоборот, в случае неуспеха общение через большой сервер.

	ИСТОРИЯ ВЕРСИЙ
	0.01
	Пользователи (клиент и сервер), соединённые по глобальной или локальной сети, могут обмениваться сообщениями по незашифрованному каналу.
	0.02
	Добавлена электронная подпись сообщений пользователей.
	0.03
	Добавлено асимметричное шифрование сообщений пользователей.
	0.04
	Добавлена поддержка технологии IPv6.
	0.05
	Добавлена возможность простой защиты от атаки «человек посередине»: пользователи могут сверить хеши от открытых ключей.
	0.06
	Добавлена возможность более продвинутой защиты от атаки «человек посередине»: пользователи могут сохранять на диск и загружать с него ключи, передавая их по защищённым каналам.
	0.07
	Добавлены сеансовые ключи, обеспечивающие свойство совершенной прямой секретности переписки, защита от атаки путём повторного воспроизведения сообщений (replay) и ограниченная защита от утаивания сообщений.
	0.08
	Добавлен графический интерфейс пользователя.
	0.09
	Switch to english.
